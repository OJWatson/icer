#' Function to create all moi permutations
#'
#' @param m Total number we are summing to
#' @param n Number of different non-negative integers used. Default = 3
#'
#' @details Creates a matrix of the different ways of adding
#'   to m with n non-negative integers.
#'
#' @return Returns a matrix with n columns, with each row summing to m.
#'
#' @examples
#' \dontrun{
#'
#' moi_perms(2,3)
#'
#' icer:::moi_perms(m = 2, n = 3)
#'
#' #>      [,1] [,2] [,3]
#' #> [1,]    0    0    2
#' #> [2,]    1    0    1
#' #> [3,]    2    0    0
#' #> [4,]    0    1    1
#' #> [5,]    1    1    0
#' #> [6,]    0    2    0
#' }

moi_perms <- function(m, n = 3) {
  expr <- parse(text = paste0("expand.grid(", paste(rep("0:m",
                                                        n - 1), collapse = ","), ")"))
  if(n-1 == 1){
    X <- t(as.matrix(eval(expr)))
    X <- t( rbind(X, X[rev(1:ncol(X))]) )
    colnames(X) <- NULL
    return(X)
  } else{
    X <- t(as.matrix(eval(expr)))
    X <- X[, colSums(X) <= m]
    X <- t(rbind(X, m - colSums(X)))
    colnames(X) <- NULL
    return(X)
  }

}

#' Creates composition types from a vector of probabilities
#'
#' @param probs Named vector of probabilities
#'
#' @details Creates a named vector of all combinations for the names
#'   in probs, separated by a "/" and sorted by character length
#'   and then alphabetically
#'
#' @return Returns a named vector of 0s.
#'
#' @examples
#' \dontrun{
#'
#' probs <- c("a" = 0.5, "b" = 0.3, "c" = 0.2)
#' icer:::generate_composition_levels(probs = probs)
#'
#' #> a     b     c   a/b   a/c   b/c a/b/c
#' #> 0     0     0     0     0     0     0
#'
#' }

generate_composition_levels <- function(probs) {

  # first lets create all the possible combinations
  levels <- parse(text = paste0("expand.grid(",
                                paste0(rep(
                                  "c(TRUE,FALSE)", length(probs)
                                ), collapse = ","),
                                ")"))
  levels <- head(eval(levels), 2 ^ length(probs) - 1)

  # tidy the names of the levels
  nms <- names(probs)
  levels <-
    (apply(levels, 1, function(x) {
      paste0(nms[x], collapse = "/")
    }))
  levels <- levels[order(nchar(levels), levels)]

  # return this as an empty numeric vector with these names
  ret <- vector("numeric", length = length(levels))
  names(ret) <- levels

  return(ret)

}

#' Creates infection types from infection compositions
#'
#' @param nms Names of the species we are looking at.
#' @param perms List of outputs of \code{moi_perms}.
#'
#' @details For each matrix of moi permutations within `perms`, each row
#'   is used to work out the infection type from the infection composition.
#'   E.g. if the row of the matrix is [2, 1, 0] and our `nms` are [a, b, c]
#'   then the infeciton composition is "a/a/b" but the observed infection
#'   type will be "a/b"
#'
#' @return Returns a list of vectors that correspond to the infection types
#'   of the infection compostions given within `perms`
#'
#' @examples
#' \dontrun{
#'
#' perms <- lapply(1:2, moi_perms, n = 3)
#' nms <- c("a", "b", "c")
#'
#' infection_types(nms,perms)
#'
#' #> [[1]]
#' #> [1] "c" "a" "b"
#' #>
#' #> [[2]]
#' #> [1] "c"   "a/c" "a"   "b/c" "a/b" "b"
#'
#' }

infection_types <- function(nms, perms) {

  infs <- lapply(perms, function(x) {
    apply(x, 1, function(x) { paste0(nms[x > 0], collapse = "/") })
  })

  return(infs)

}

#' Converts infection probability densities to multinomial probabilities
#'
#' @param pci_list List of length 3:
#'   * `perms`: list of permutations as generated by
#'   `lapply(1:n, \code{moi_perms}, ...).
#'   * `comps`: vector of the levels of possible infection types
#'   generated by \code{generate_composition_levels}
#'   * `infs`: list of corresponding infection types as generated by
#'   \code{infection_types}
#' @param densities List of numeric vectors describing the probability density
#'   of each infection composition within `pci_list$perms`.
#'
#' @details Creates a matrix with each row being the mutlinomial distribution
#'   describing the probability of each infection type for a given moi. These
#'   rows are calculated by summing the probability densities in `densities`
#'   that correspond to each infection type which is contained within
#'   `pci_list$infs`.
#'
#' @return Returns a matrix with n columns, and m rows, where m is the maximum
#'   moi specified in your coccurence test..
#'
#' @examples
#' \dontrun{
#'
#' # our given probs
#' probs <- c("a" = 0.5, "b" = 0.3, "c" = 0.2)
#' comps <- generate_composition_levels(probs)
#'
#' # generate some perumtations of infection compositions up to 2
#' perms <- lapply(1:2, moi_perms, n = 3)
#'
#' perms
#' #> [[1]]
#' #> [,1] [,2] [,3]
#' #> [1,]    0    0    1
#' #> [2,]    1    0    0
#' #> [3,]    0    1    0

#' #> [[2]]
#' #> [,1] [,2] [,3]
#' #> [1,]    0    0    2
#' #> [2,]    1    0    1
#' #> [3,]    2    0    0
#' #> [4,]    0    1    1
#' #> [5,]    1    1    0
#' #> [6,]    0    2    0
#'
#' # and the infection types
#' infs <- infection_types(names(probs), perms)
#' infs
#' #> [[1]]
#' #> [1] "c" "a" "b"
#' #>
#' #> [[2]]
#' #> [1] "c"   "a/c" "a"   "b/c" "a/b" "b"
#'
#' # create the pci_list
#' pci_list <- list("perms" = perms, "comps" = comps, "infs" = infs)
#'
#' # and also let's work out the probability densities for these infections
#' densities <- lapply(pci_list$perms, function(x){
#'   dens <- apply(x, 1, dmultinom, size = sum(x[1,]), prob = probs)
#' })
#'
#' densities
#' #> [[1]]
#' #> [1] 0.2 0.5 0.3
#' #>
#' #> [[2]]
#' #> [1] 0.04 0.20 0.25 0.12 0.30 0.09
#'
#' # and create the multinomial matrix
#' comp_dens_to_multi_dens(pci_list, densities)
#' #>         a    b    c a/b a/c  b/c a/b/c
#' #> [1,] 0.50 0.30 0.20 0.0 0.0 0.00     0
#' #> [2,] 0.25 0.09 0.04 0.3 0.2 0.12     0
#'
#' }

comp_dens_to_multi_dens <- function(pci_list, densities) {

  multi_dens <- mapply(pci_list$infs, densities, FUN = function(infs, dens) {

    dens_inf <- pci_list$comps
    for (i in names(dens_inf)) {
      dens_inf[i] <- sum(dens[infs == i])
    }
    return(dens_inf)

  })

  multi_dens <- t(multi_dens)
  return(multi_dens)
}



#' Create multinomial distribution for infection probabilities
#'
#' @param multi_dens Matrix where each row gives the probability density of
#'   each infection type for a given multiplicity of infection.
#' @param params Parameter vector. Must contain at least one value named `mu`,
#'   which is the mean muliplicity of infection. Could also contain `size` in
#'   which case negative binomial distribution is used. See details.
#'
#' @details Using either a poisson or negative binomial distribution, the
#'   probability of drawing `1:nrow(multi_dens)` for the parmeters provided is
#'   calculated. These are used as weights to then calculate the weighted mean
#'   probability of each infection type (the columns in `multi_dens`).
#'
#' @return Returns a named multinomial probability distribution.
#'
#' @examples
#' \dontrun{
#'
#' # create our arguments
#' multi_dens <- matrix(c(0.5,0.3,0.2,0,0,0,0,
#'                        0.25,0.09,0.04,0.3,0.2,0.12,0),
#'                         nrow = 2,byrow=TRUE)
#' colnames(multi_dens) <- c("a", "b", "c", "a/b", "a/c", "b/c", "a/b/c")
#'
#' # first calculating using a poisson
#' params <- c("mu" = 2)
#' infection_probabilities(multi_dens, params)
#' #>     a     b     c   a/b   a/c   b/c a/b/c
#' #> 0.375 0.195 0.120 0.150 0.100 0.060 0.000
#'
#' # no using the negative binomial
#' params <- c("mu" = 2, "size" = 1)
#' infection_probabilities(multi_dens, params)
#' #>     a     b     c   a/b   a/c   b/c a/b/c
#' #> 0.400 0.216 0.136 0.120 0.080 0.048 0.000
#'
#' }

infection_probabilities <- function(multi_dens, params) {

  # range quantiles for distributions
  x <- seq_len(nrow(multi_dens))

  # if the params has a size parameter use a neg binomial distribution
  if ("size" %in% names(params)) {

    w <- dnbinom(x, mu = params["mu"], size = params["size"])
    w <- w / (1 - dnbinom(0, mu = params["mu"], size = params["size"]))

    # otherwise we will use the poisson
  } else {

    w <- dpois(x, lambda = params["mu"])
    w <- w / (1 - dpois(0, lambda = params["mu"]))

  }

  multi_dens <- apply(multi_dens, 2, weighted.mean, w)


  return(multi_dens)
}

#' Independent model of strain acquisition
#'
#' @param params Vector of parameters including the frequency of each species
#'   and the mean moi mu.
#' @param data Real data to compare model predictions to.
#' @param pci_list Permutation, composition and infections list.
#' @param max_moi Maxuimum infction composition explored. Default = 25.
#' @details For a given frequency of each strain and mean moi, returns the
#'   related multionomial distribution describing each infection type.
#'
#' @return Returns a named multinomial probability distribution.
independent <- function(params, data, pci_list,  max_moi = 25) {

  # handle frequency params
  # ------------------------------------
  n_sp <- ncol(pci_list$perms[[1]])
  freqs <- params[seq_len(n_sp)]
  freqs <- freqs / sum(freqs)

  # Density of each infection composition using a multinomial distribution
  densities <- lapply(pci_list$perms, function(x){
    dens <- apply(x, 1, dmultinom, size = sum(x[1,]), prob = freqs)
  })

  # turn these into a a matrix of multinomial densities
  multi_dens <- comp_dens_to_multi_dens(pci_list = pci_list, densities = densities)

  # calculate the overall multinomial distributon
  probs <- infection_probabilities(multi_dens,  params)
  return(probs)

}

#' Interference mutlinomial distribution
#'
#' @param x Vector of length equal to `data` of integers in `0:sum(data)`.
#' @param prob Numeric non-negative vector of length `length(data)`, specifying
#'   the probability for classes; is internally normalized to sum 1.
#'   Infinite and missing values are not allowed.
#' @param k Interference parameters. See details.
#' @param interf Interference relationships. Output of \code{interf_pair_pos}
#'
#' @details Interference parameters describe how the probability density of
#'   `dmultionom(x, prob=prob)` is altered depending on which is the first draw
#'   from the mutlinomial distribution.
#'
#'   Two types of interference parameter can be specified. For example:
#'
#'   Modulators, which should be passed as a named vector, with names "k<n>":
#'
#'   `k = c("k0"=0.5)` - The probability of choosing the same event as the first
#'    drawn event will be mutliplied by 0.5
#'   `k = c("k1"=0.5,"k2"=2)` - The probability of choosing the first element in
#'    x again if it was drawn first will be multiplied by 0.5, whereas if the
#'    second element was drawn first then the probability of picking it again is
#'    doubled.
#'    drawn event will be mutliplied by 0.5
#'
#'   Interferences, passed as a named vector, with names "k_<n>_<m>":
#'
#'   `k = c("k_1_2" = 0.5, "k_1_3" = 2, "k_2_3")` - The probability of choosing
#'    event 1 if event 2 drawn first is half, and vice versa. The probability
#'    of drawing event 1 if event 3 was drawn first is doubled, and vice versa.
#'    The probability of drawing event 2 if event 3 was drawn first is doubled,
#'    and vice versa.
#'    drawn event will be mutliplied by 0.5
#'    Interferences are thus symmetrical between events.
#'
#' @return Returns probability density vector of length equal to `length(prob)`
interf_dmultinom <- function(x, prob, k, interf){

  # which positions in x could have been drawn first
  pos <- which(x > 0)

  # create our density to be added to for each possible first draw
  dens <- 0

  # if interference
  if(!is.logical(interf)){

    # loop through each positon in x that could be decreased
    for(i in pos){
      x_new <- x
      x_new[i] <- x_new[i]-1
      prob_new <- prob
      prob_new[interf$p[[i]]] <- prob_new[interf$p[[i]]]*k[interf$k[[i]]]
      dens <- dens + dmultinom(x_new, prob=prob_new) * prob[i]
    }

    # otherwise we are doing modulation
  } else {

    for(i in pos){
      x_new <- x
      x_new[i] <- x_new[i]-1
      prob_new <- prob
      prob_new[i] <- prob_new[i]*k[i]
      dens <- dens + dmultinom(x_new,prob=prob_new) * prob[i]
    }

  }
  return(dens)
}

#' @noRd
interf_pair_pos <- function(k, n) {

  if(all(grepl("_", names(k)))){
    interf <- list()
    interf$k <- lapply(seq_len(n), grep, names(k))
    interf$p <- lapply(seq_len(n), function(x){
      p_ch <- grep(x, names(k))
      v <- unlist(strsplit(gsub("k_([0-9]+)$", "\\1", names(k[p_ch])),""))
      v <- v[v!=as.numeric(x)]
      return(as.numeric(v))
    })
  } else {
    interf <- FALSE
  }

  return(interf)
}

#' Interference model of strain acquisition
#'
#' @param params Vector of parameters including the frequency of each species
#'   and the mean moi mu.
#' @param data Real data to compare model predictions to.
#' @param pci_list Permutation, composition and infections list.
#' @param max_moi Maxuimum infction composition explored. Default = 25.
#'
#' @details For a given frequency of each strain and mean moi, returns the
#'   related multionomial distribution describing each infection type. `params`
#'   vector can contain extra parameters `k...` that describe the interference.
#'   See \code{interf_dmultinom} for how to format these parameters.
#'
#' @return Returns a named multinomial probability distribution.
interference <- function(params, data, pci_list,  max_moi = 25) {

  # handle frequency params
  # ------------------------------------
  n_sp <- ncol(pci_list$perms[[1]])
  freqs <- params[seq_len(n_sp)]
  freqs <- freqs / sum(freqs)

  # grab parameters related to interference
  k <- params[grep("k_|k\\d", names(params))]
  if(length(k) == 0){
    k <- 1
  }

  # adjust k if it is only one parameter long
  if(length(k) == 1){
    k <- rep(k, n_sp)
  }

  # what is the interference relationship
  interf <- interf_pair_pos(k, n_sp)

  # Density of each infection composition using a multinomial distribution
  densities <- lapply(pci_list$perms, function(x){
    dens <- apply(x, 1, interf_dmultinom, prob = freqs, k = k, interf = interf)
  })

  # turn these into a a matrix of multinomial densities
  multi_dens <- comp_dens_to_multi_dens(pci_list = pci_list, densities = densities)

  # calculate the overall multinomial distributon
  probs <- infection_probabilities(multi_dens,  params)
  return(probs)

}

ll_function <- function(params, data, pci_list,
                        density_func = independent,
                        max_moi = 25) {

  # pass the parameters to our density function
  probs <- density_func(params, data, pci_list, max_moi)

  # calculate the log likelihood using the output multinomial prob distribution
  ll <- dmultinom(data, size = sum(data), prob = probs, log = TRUE)

  return(ll)

}

#' Co-occurence test
#'
#' Maximum likelihood test and plotted results for coinfection dynamics
#' @param data Observed data. Either as a named vector or a 2 column
#'   \code{\link{data.frame}}. See examples for more info.
#' @param density_func Function that calculates the multinomial distribution
#'   describing the data. Default = \code{independent}
#' @param max_moi Maxuimum infction composition explored. Default = 25.
#' @param poisson Logical for determining if we use a poisson distribution to
#'   describe the numer of infection occurences. Default = `FALSE`, which means
#'   a negative binomial is used. `
#' @param size Starting value for the negative binomial size parameter.
#'   Default = 100.
#' @param boot_iter Bootstrap iterations. Default = 10000
#' @param plot Boolean for default plotting the bootsrap results. Default = TRUE
#' @param quantiles Vector of length 2 for the quantiles used. Default = `c(0.025, 0.975)`
#' @param lower Vector of lower bounds used in fitting. Default = NULL, which will
#'   create a vector with 0.0001 for each frequency and 0.1 for the moi.
#' @param upper Vector of upper bounds used in fitting. Default = NULL, which will
#'   create a vector with 0.9999 for each frequency and `max_moi` for the moi.
#' @param ... Any other arguments that will be passed to `density_func``
#' @rdname cooccurence_test
#'
#' @details Estimates the maximum likely population frequency of each species
#'   (i.e. the names of the observed entities in our data) and the mean number
#'   of infections given our observed data. These estimates are used to estimate
#'   the multinomial probability distribution for all cooccurences and comparing
#'   these to our data using a boostrap method.
#'
#' @return Invisibly returns a list containing the estimated parameters
#'   and a plot of our data compared to the boostrapped estimates.
#' @export
#'
#' @examples
#' \dontrun{
#'
#' # example of the two forms of data type accepted
#' real <- data.frame(
#' "variable"=c("pf/po","pf/pv","pf/po/pv","pf","po","po/pv","pv"),
#' "value"=c(84,179,1,5181,44,1,309)
#' )
#'
#' real <- c(
#' "pf/po" = 84, "pf/pv" = 179, "pf/po/pv" = 1,
#' "pf" = 5181, "po" = 44, "po/pv" = 1, "pv" = 309
#' )
#'
#' res <- cooccurence_test(data = real)
#'
#' }
cooccurence_test <- function(data, density_func = independent,
                             max_moi = 25, poisson = FALSE,
                             size = 100,
                             boot_iter = 10000, plot = TRUE,
                             quantiles = c(0.025, 0.975),
                             lower = NULL, upper = NULL,
                             ...) {

  # format our input data
  # ----------------------------------------------------------------------------

  # firstly is the data provided in a dataframe or does it need to be converted
  if (is.data.frame(data)) {
    real <- data
    classes <- sapply(data, class)
    fid <- c(c(1:2)[-which(classes == "numeric")],which(classes == "numeric"))
    names(real) <- c("variable", "value")[fid]
  } else {
    real <- data.frame("variable" = names(data),
                       "value" = as.numeric(data))
  }

  # tidy up the resultant data frame
  real$variable <- strsplit(as.character(real$variable), "/") %>%
    lapply(sort) %>%
    lapply(paste0, collapse = "/") %>%
    tolower %>%
    unlist
  data <- real$value
  names(data) <- tolower(real$variable)

  # create starting parameters
  # ----------------------------------------------------------------------------

  # useful starting parameters for the probabilities
  total <- sum(real$value)
  spcs <- sort(strsplit(as.character(real$variable), "/") %>% unlist %>% unique())
  start <- sapply(spcs, function(x) {
    sum(real$value[grep(x, real$variable)]) / total
  })
  freq_length <- length(start)

  # add the mean number of infections to our parameter list
  start <- c(start/sum(start), "mu" = 2)

  # length of parameter starting values now
  len_s <- length(start)

  # are we using a poisson or neg binomial for infections
  if (!poisson) {
    start <- c(start, "size" = size)
  }

  # add any additonal parameters that need to be fit relevant to model
  start <- c(start, ...)

  # how many new parameters have been added to the basic parameter list
  new <- tail(start, length(start) - len_s)

  # check on bounds
  if (is.null(lower)) {
    lower <- c(rep(0.0001,freq_length), 0.1, new*0.01)
  }
  start <- apply(rbind(start,lower),2,max)

  if (is.null(upper)) {
    upper <- c(rep(0.9999,freq_length), 25, new*100)
  }
  start <- apply(rbind(start,upper),2,min)

  # create permutation objects once here for speed
  # ----------------------------------------------

  # generate our moi permutations once here and pass as extra argument
  perms <- lapply(1:max_moi, FUN = moi_perms, n = freq_length)

  # and also set up the list of types of infection status from this
  comps <- generate_composition_levels(probs = start[seq_len(freq_length)])

  # and order our data passed in this way and fill in blanks
  data <- data[match(names(comps), names(data))]
  data[is.na(data)] <- 0
  names(data) <- names(comps)

  # lastly for each infection permutation what is the observed infection
  nms <- names(start[seq_len(freq_length)])
  infs <- infection_types(nms = nms, perms = perms)

  pci_list <- list("perms" = perms, "comps" = comps, "infs" = infs)

  # model fitting
  # ----------------------------------------------

  # fit our best model
  fit <- optim(
    par = start,
    fn = ll_function,
    data = data,
    pci_list = pci_list,
    density_func = density_func,
    max_moi = max_moi,
    method = "L-BFGS-B",
    lower = lower,
    upper = upper,
    control = list(
      trace = TRUE,
      fnscale = -1,
      maxit = 10000
    ),
    hessian = TRUE
  )

  # work out what the resultant multinomial distribution was
  fitted_multinomial <- density_func(params = fit$par, data = data,
                                     pci_list = pci_list, max_moi = max_moi)

  # remember to format the probabilities so they add to 1 for reporting reasons
  freqs <- head(fit$par, freq_length)
  freqs <- freqs / sum(freqs)
  fit$par[seq_len(freq_length)] <- freqs

  # create the bootstrapped coinf plot
  coinf <- coinf_plot(
    reps = boot_iter,
    probs = fitted_multinomial ,
    levels = names(fitted_multinomial),
    total = sum(data),
    plot = plot,
    real = real
  )

  # grab the fit
  params <- list("params" = fit$par,
                 "multinom" = fitted_multinomial)

  ret <- list("params" = params, "data" = data, "plot" = coinf,
              "fit" = fit, "pci_list" = pci_list)
  class(ret) <- "icer_cooccurence_test"

  # return the fit, data and the plot
  invisible(ret)

}

